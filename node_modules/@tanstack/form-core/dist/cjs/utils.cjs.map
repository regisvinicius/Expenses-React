{"version":3,"file":"utils.cjs","sources":["../../src/utils.ts"],"sourcesContent":["import { defaultValidationLogic } from './ValidationLogic'\nimport type { ValidationLogicProps } from './ValidationLogic'\nimport type { FieldValidators } from './FieldApi'\nimport type { FormValidators } from './FormApi'\nimport type {\n  GlobalFormValidationError,\n  ValidationCause,\n  ValidationError,\n  ValidationSource,\n} from './types'\n\nexport type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\n/**\n * @private\n */\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n * @private\n */\nexport function getBy(obj: any, path: any) {\n  const pathObj = makePathArray(path)\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (current === null) return null\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n * @private\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (\n      typeof key === 'string' ||\n      (typeof key === 'number' && !Array.isArray(parent))\n    ) {\n      if (typeof parent === 'object') {\n        if (parent === null) {\n          parent = {}\n        }\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (Array.isArray(parent) && typeof key === 'number') {\n      const prefix = parent.slice(0, key)\n      return [\n        ...(prefix.length ? prefix : new Array(key)),\n        doSet(parent[key]),\n        ...parent.slice(key + 1),\n      ]\n    }\n    return [...new Array(key), doSet()]\n  }\n\n  return doSet(obj)\n}\n\n/**\n * Delete a field on an object using a path, including dot notation.\n * @private\n */\nexport function deleteBy(obj: any, _path: any) {\n  const path = makePathArray(_path)\n\n  function doDelete(parent: any): any {\n    if (!parent) return\n    if (path.length === 1) {\n      const finalPath = path[0]!\n      if (Array.isArray(parent) && typeof finalPath === 'number') {\n        return parent.filter((_, i) => i !== finalPath)\n      }\n      const { [finalPath]: remove, ...rest } = parent\n      return rest\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doDelete(parent[key]),\n        }\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        if (key >= parent.length) {\n          return parent\n        }\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doDelete(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n    }\n\n    throw new Error('It seems we have created an infinite loop in deleteBy. ')\n  }\n\n  return doDelete(obj)\n}\n\nconst reLineOfOnlyDigits = /^(\\d+)$/gm\n// the second dot must be in a lookahead or the engine\n// will skip subsequent numbers (like foo.0.1.)\nconst reDigitsBetweenDots = /\\.(\\d+)(?=\\.)/gm\nconst reStartWithDigitThenDot = /^(\\d+)\\./gm\nconst reDotWithDigitsToEnd = /\\.(\\d+$)/gm\nconst reMultipleDots = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\n/**\n * @private\n */\nexport function makePathArray(str: string | Array<string | number>) {\n  if (Array.isArray(str)) {\n    return [...str]\n  }\n\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return (\n    str\n      // Leading `[` may lead to wrong parsing down the line\n      // (Example: '[0][1]' should be '0.1', not '.0.1')\n      .replace(/(^\\[)|]/gm, '')\n      .replace(/\\[/g, '.')\n      .replace(reLineOfOnlyDigits, intReplace)\n      .replace(reDigitsBetweenDots, `.${intReplace}.`)\n      .replace(reStartWithDigitThenDot, `${intReplace}.`)\n      .replace(reDotWithDigitsToEnd, `.${intReplace}`)\n      .replace(reMultipleDots, '.')\n      .split('.')\n      .map((d) => {\n        if (d.startsWith(intPrefix)) {\n          const numStr = d.substring(intPrefix.length)\n          const num = parseInt(numStr, 10)\n\n          if (String(num) === numStr) {\n            return num\n          }\n          return numStr\n        }\n        return d\n      })\n  )\n}\n\n/**\n * @private\n */\nexport function concatenatePaths(path1: string, path2: string): string {\n  if (path1.length === 0) return path2\n  if (path2.length === 0) return path1\n\n  if (path2.startsWith('[')) {\n    return path1 + path2\n  }\n\n  // In cases where parent and child withFieldGroup forms are both nested\n  if (path2.startsWith('.')) {\n    return path1 + path2\n  }\n\n  return `${path1}.${path2}`\n}\n\n/**\n * @private\n */\nexport function isNonEmptyArray(obj: any) {\n  return !(Array.isArray(obj) && obj.length === 0)\n}\n\ninterface AsyncValidatorArrayPartialOptions<T> {\n  validators?: T\n  asyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface AsyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n  debounceMs: number\n}\n\ninterface SyncValidatorArrayPartialOptions<T> {\n  validators?: T\n}\n\n/**\n * @private\n */\nexport interface SyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n}\n\n/**\n * @private\n */\nexport function getSyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: SyncValidatorArrayPartialOptions<T> & {\n    validationLogic?: any\n    form?: any\n  },\n): T extends FieldValidators<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n  ? Array<\n      SyncValidator<\n        | T['onChange']\n        | T['onBlur']\n        | T['onSubmit']\n        | T['onMount']\n        | T['onDynamic']\n      >\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any, any, any>\n    ? Array<\n        SyncValidator<\n          | T['onChange']\n          | T['onBlur']\n          | T['onSubmit']\n          | T['onMount']\n          | T['onDynamic']\n        >\n      >\n    : never {\n  const runValidation = (\n    props: Parameters<ValidationLogicProps['runValidation']>[0],\n  ) => {\n    return props.validators.filter(Boolean).map((validator) => {\n      return {\n        cause: validator!.cause,\n        validate: validator!.fn,\n      }\n    })\n  }\n\n  return options.validationLogic({\n    form: options.form,\n    validators: options.validators,\n    event: { type: cause, async: false },\n    runValidation,\n  })\n}\n\n/**\n * @private\n */\nexport function getAsyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: AsyncValidatorArrayPartialOptions<T> & {\n    validationLogic?: any\n    form?: any\n  },\n): T extends FieldValidators<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n  ? Array<\n      AsyncValidator<\n        | T['onChangeAsync']\n        | T['onBlurAsync']\n        | T['onSubmitAsync']\n        | T['onDynamicAsync']\n      >\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any, any, any>\n    ? Array<\n        AsyncValidator<\n          | T['onChangeAsync']\n          | T['onBlurAsync']\n          | T['onSubmitAsync']\n          | T['onDynamicAsync']\n        >\n      >\n    : never {\n  const { asyncDebounceMs } = options\n  const {\n    onBlurAsyncDebounceMs,\n    onChangeAsyncDebounceMs,\n    onDynamicAsyncDebounceMs,\n  } = (options.validators || {}) as\n    | FieldValidators<\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any\n      >\n    | FormValidators<any, any, any, any, any, any, any, any, any, any>\n\n  const defaultDebounceMs = asyncDebounceMs ?? 0\n\n  const runValidation = (\n    props: Parameters<ValidationLogicProps['runValidation']>[0],\n  ) => {\n    return props.validators.filter(Boolean).map((validator) => {\n      const validatorCause = validator?.cause || cause\n\n      let debounceMs = defaultDebounceMs\n\n      switch (validatorCause) {\n        case 'change':\n          debounceMs = onChangeAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'blur':\n          debounceMs = onBlurAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'dynamic':\n          debounceMs = onDynamicAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'submit':\n          debounceMs = 0 // submit validators are always run immediately\n          break\n        default:\n          break\n      }\n\n      if (cause === 'submit') {\n        debounceMs = 0\n      }\n\n      return {\n        cause: validatorCause,\n        validate: validator!.fn,\n        debounceMs: debounceMs,\n      }\n    })\n  }\n\n  return options.validationLogic({\n    form: options.form,\n    validators: options.validators,\n    event: { type: cause, async: true },\n    runValidation,\n  })\n}\n\nexport const isGlobalFormValidationError = (\n  error: unknown,\n): error is GlobalFormValidationError<unknown> => {\n  return !!error && typeof error === 'object' && 'fields' in error\n}\n\nexport function evaluate<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Date && objB instanceof Date) {\n    return objA.getTime() === objB.getTime()\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) {\n    return false\n  }\n\n  for (const key of keysA) {\n    // performs recursive search down the object tree\n\n    if (\n      !keysB.includes(key) ||\n      !evaluate(objA[key as keyof T], objB[key as keyof T])\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the form level sync/async validation.\n * @private\n */\nexport const determineFormLevelErrorSourceAndValue = ({\n  newFormValidatorError,\n  isPreviousErrorFromFormValidator,\n  previousErrorValue,\n}: {\n  newFormValidatorError: ValidationError\n  isPreviousErrorFromFormValidator: boolean\n  previousErrorValue: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // All falsy values are not considered errors\n  if (newFormValidatorError) {\n    return { newErrorValue: newFormValidatorError, newSource: 'form' }\n  }\n\n  // Clears form level error since it's now stale\n  if (isPreviousErrorFromFormValidator) {\n    return { newErrorValue: undefined, newSource: undefined }\n  }\n\n  // At this point, we have a preivous error which must have been set by the field validator, keep as is\n  if (previousErrorValue) {\n    return { newErrorValue: previousErrorValue, newSource: 'field' }\n  }\n\n  // No new or previous error, clear the error\n  return { newErrorValue: undefined, newSource: undefined }\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the field level sync/async validation.\n * @private\n */\nexport const determineFieldLevelErrorSourceAndValue = ({\n  formLevelError,\n  fieldLevelError,\n}: {\n  formLevelError: ValidationError\n  fieldLevelError: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // At field level, we prioritize the field level error\n  if (fieldLevelError) {\n    return { newErrorValue: fieldLevelError, newSource: 'field' }\n  }\n\n  // If there is no field level error, and there is a form level error, we set the form level error\n  if (formLevelError) {\n    return { newErrorValue: formLevelError, newSource: 'form' }\n  }\n\n  return { newErrorValue: undefined, newSource: undefined }\n}\n\nexport function createFieldMap<T>(values: Readonly<T>): { [K in keyof T]: K } {\n  const output: { [K in keyof T]: K } = {} as any\n\n  for (const key in values) {\n    output[key] = key\n  }\n\n  return output\n}\n\n/**\n * Merge the first parameter with the given overrides.\n * @private\n */\nexport function mergeOpts<T>(\n  originalOpts: T | undefined | null,\n  overrides: T,\n): T {\n  if (originalOpts === undefined || originalOpts === null) {\n    return overrides\n  }\n\n  return { ...originalOpts, ...overrides }\n}\n"],"names":[],"mappings":"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"}